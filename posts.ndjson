{"created_ts":1604734524000,"modified_ts":1604734524000,"title":"Hacking an RTX 3080","body_markdown":"This season has been insane for PC hardware. Nvidia's new RTX 3000 series lineup is boasting rarely-seen performance at a fraction of the cost. I've had my mind set on doing an [SFFPC](https://www.reddit.com/r/sffpc/) build at some point, and found a fantastic [case](https://ncases.com/products/m1) that should easily accommodate an [RTX 3080 Founder's Edition](https://www.nvidia.com/en-us/geforce/graphics-cards/30-series/rtx-3080/). This sleek card was set to sell at [$300 less than a RTX 2080ti](https://www.tomsguide.com/news/nvidia-Rrtx-3080-vs-rtx-2080-ti#:~:text=RTX%202080%20Ti%3A%20Price%20and,has%20the%20older%20card%20beat.) while offering a [20-45% increase in performance](https://assets.rockpapershotgun.com/images/2020/09/RTX-3080-vs-2080-Ti-4K-ultra-benchmarks.jpg) - an obvious choice for the average consumer.\n\n**Stock Issues**\n\nFrom day one of the release, this card has been consistently sold out and is nearly impossible to obtain. Ebay scalpers are having a hayday by selling cards for 3 to 4 times more than MSRP. As previously mentioned, it seems many people agree that the value for computing power is too good to pass up, and Nvidia is unable to keep up with demand.\n\nWith demand and the opportunity to profit, less ethical hackers began frantically [pushing out software to place orders for them](https://www.eteknix.com/nvidia-apologizes-3080-going-out-of-stock/) when stock became available. Nvidia either wasn't able or wasn't willing to implement a system to prevent these sales (IE [reCAPTCHA](https://www.google.com/recaptcha/about/)). _To be fair, why would they? A sale is a sale - hard to blame them_. However, to circumvent traffic and logistics issues, Nvidia [pushed the responsibility](https://www.techradar.com/news/nvidia-admits-defeat-with-rtx-3080-and-3090-founders-edition-stock-passes-baton-to-best-buy) to a single retailer in the US - Best Buy.\n\nThis is good news, right? A large online retailer such as Best Buy would clearly already have measures in place to solve the problems Nvidia was facing, right? Right...? You've probably guessed by now - that isn't what happened. Frankly, the issues may be even be worse due to Best Buy's various [sporadic and widespread failures](https://www.reddit.com/r/nvidia/comments/jjvig1/3080_fe_available_on_best_buy/) throughout the multi-step ordering process. At face value, there is still nothing in place to prevent automated orders from being placed.\n\n**The 'Solution'**\n\nIf you can't beat them, join them! Okay, not really... once again, I am plagued by an overbearing urge to not use my skills for evil.\n\nAside from reliability, Best Buy actually has a very nice API. The frontend does what it should and makes requests (item info & stock / add to cart / checkout, etc) using the API. It would be all too easy to make all of the necessary requests to place an order immediately when stock is available. However, I'm not quite ready to see myself become the villain.\n\nAs a compromise, I limited my hacking to focus only on the endpoint that (given a sku) returns that item's stock status. As far as I know, there is only one flag that I'm interested in: `buttonState: SOLD_OUT`. The premise is simple enough, make a request every `x` seconds (randomized) to see if this flag has changed - if it has, send an email to notify. The program also logs each result, so a terminal can be monitored in real-time.\n\n**Reinventing the wheel?**\n\nIt's not unfair to say that this problem already has a solution. There are [stock-checkers available online](https://www.nowinstock.net/computers/videocards/nvidia/rtx3080/) that are free to use. I haven't looked into them much but I've seen that higher-interval tools require paid plans and have browser dependencies. The goal for me is to outperform these tools if possible - implementing my own solution will allow me to finely tune my intervals to as low as possible while still avoiding detection. Besides, this is a fun project!\n\n**Challenges**\n\nTruthfully, there's not a lot to talk about here. Best Buy's API expects certain request headers to be set or else it will return a 400 error code. Finding the relevant headers was a trivial case of trial and error. Everything else worked exactly as expected. I opted to use [`node-fetch`](https://github.com/node-fetch/node-fetch) for the requests to the API, and [`gmail-send`](https://github.com/alykoshin/gmail-send) to send myself an email when the stock is no longer listed as `SOLD_OUT`.\n\n**Code**\n\nI'll just drop this in as a [gist](https://gist.github.com/d-r-w/2b5071a2d54f6ca83ca561a9df7ba1a3) for those who may be interested.\n\n**The Outcome**\n\nThis is the part where I'd _love_ to say that the initiative paid off in the end and I secured myself a graphics card that is borderline impossible to obtain. Alas, things don't always work out as expected.\n\nAt the time of writing this post, the stock status has changed only a single time in three weeks. I have been monitoring the logs as much as could be considered as only slightly unhealthy. The one time the stock did change, I (sadly) wasn't actively using a device that would have notified me. I missed the notification by about 90 seconds. I was still able to begin the ordering process, but others were notified by their services by then and the API was behaving too erratically for my order to be placed successfully.\n\nI'm painfully aware that it's not the most exciting outcome, but I am grateful for the opportunity that presented itself to me. There is great enjoyment in writing fulfilling code that serves a real-world purpose, even if it hasn't quite found its moment to produce results - and I am still running currently running the program (wish me luck!).","_id":"2AjejodDJK"}
{"created_ts":1595089968792,"modified_ts":1595089968792,"title":"First post!","body_markdown":"This is my first published blog post. Well, it’s not actually published quite yet because this post is about building the blogging platform itself!\n\nMy personal hobby of a website is currently hosted with nodejs on a raspberry pi in my home. I’m aware that this setup isn’t the best idea, and is very possibly a bad idea...but it is fun. Not only do I save on hosting costs, I get the fulfillment of building my own solutions and getting some experience as I go.\n\nI’m considering building a basic CMS - nothing crazy, just a relatively simple way to load and display posts like these. To reduce complexities, this should be the main engine of my website. This wouldn’t be my first time building something similar to a CMS - one of my first ever websites (think Geocities days) implemented something like this. I’m not sure there was even a name for it back then. That’s not to imply that the idea was new, several places on the internet were doing similar things (pretty sure I got the idea from Xanga). A more resilient example would probably be Blogger.\n\nNode is a preference for this project because it’s so simple to spin anything up. Even now, I’m hosting a landing page using only a few lines of code. My hopes are to build upon this in an effort to make pushing out blog posts like these easier.\n\nThe idea is pretty straightforward...have the node webserver pull blog posts from a nosql database and render HTML to style the blog posts.\n\n- [Express](https://expressjs.com/)\n- [EJS](https://ejs.co/)\n - React/similar seems to be a bit over-the-top, but backend templating should be clean and not overly convoluted\n- [Marked.js](https://marked.js.org/) to format blog posts and make storing them simple and inexpensive\n- [neDB](https://github.com/louischatriot/nedb)\n - Prefer NoSQL for this, and embedded is preferred (less moving parts on the Pi is inevitably for the best)\n\n_Sidenote: I’m finally switching to [vscode](https://code.visualstudio.com/). I finally got around to testing it out on my hackbook (cheap little chromebook) and it runs surprisingly well. I’m ashamed for not switching sooner. Due to its superb git integration, switching also affords me the ability to drop the fancy graphical git tools I’ve been using._\n\n### Express ###\n\nSet up an HTTP server, handle requests. Interface with EJS to render HTML, interface with database to load posts.\n\n### Database ###\nI have some experience with neDB, and think it will be a perfect fit for this project. The lack of binaries and dependencies keep everything very simple. I’m thinking (for now) I’ll just more or less make a flat file of `posts`. Each post would have a `created_ts`, `modified_ts`, `title`, and `markdown_body`. neDB is great on its own, but I’d like to use a promisified version of it - for that I’ll use the package [`nedb-promises`](https://github.com/bajankristof/nedb-promises) - this will allow me to use async/await instead of callbacks. I think that’s really all there is to say about the database, nothing fancy.\n\n### Marked.js ###\nAnother simple idea. Store markdown directly in the database so fancy formatting can be applied during rendering using a call to `marked()`. Stylings can be applied during rendering.\n\n### EJS ###\nThis is probably the most complicated bit, but only due to the fact that rendering the HTML and CSS was likely always going to be the most complicated part of this project. It would be easy enough to just render some basic HTML along with serving static files, but I think a good way to keep everything tidy and uniform will be using EJS. That being said, it’s still _really_ not complicated at all. Just throwing some loops and formatting into a `.ejs` file and calling it good. Bootstrap is sort of a cop out, but it’s undeniably simple. I’ll just pull from a CDN and apply some basic formatting.\n\n### The Future ###\nIdeally, this is a very rough version of what I hope to be a portfolio website. There are some pretty glaring issues at this point, mostly that there’s no real landing page and the index page is just displaying every post. Obviously it makes a lot more sense to group posts by date, maybe show last x posts as cards with a snippet of the content (definitely not the entire body).\n\nThe current working version is pretty lightweight, but the code is as well - I'm ruling it a success.\n\nCheck out the code at:\n### [https://github.com/d-r-w/dwhite-codes](https://github.com/d-r-w/dwhite-codes) ###","_id":"At3WI6HESEpKwHJD"}
{"created_ts":1611530439896,"modified_ts":1611530439896,"title":"Publishing Posts","body_markdown":"I need a less cumbersome way to publish posts. There's nothing significantly _wrong_ with what I'm doing now, but it's certainly not the best way to go about it.\n\nI want the ability to edit and see the markdown live. I also want a way to supply credentials and just insert the post directly into the database from the website itself. \n\n##### Live Preview\nI think a simple way to go about this will be simply sending a `fetch` request to a new `marked.json` endpoint where the server can just do a call to `marked()` and send the returned value in a response. This can be triggered with an `oninput` attribute attached to a `textarea`.\n\n##### Publishing\nPerhaps not the best way to go about it, but having a \"post title\" text input, \"key\" text input, and \"submit\" button would likely do the trick. The button will have an `onclick` event attribute that will perform a `fetch` call to `publish_post.json`. Normally this would be fine with HTTPs, but there is a concern that this isn't currently implemented on my server.. I should probably look into that. Because this will be sent in HTTP, there's potential for bad actors on the network to see the key in cleartext and add nefarious posts to the database. I'll take the risk for now but I do want to keep this on the radar. The key will be set on the server with a `process.env` variable. If the key matches, the post will be added. Otherwise, a `403` HTTP status code will be returned.","_id":"TWO6mKmDtJFgSOEy"}
{"created_ts":1611530265782,"modified_ts":1611530265782,"title":"Nixing EJS Rendering","body_markdown":"##### The problem\nI'm quickly discovering that I'm just not a fan of using EJS rendering for this project website.\nI understand the typical use cases for it, but I'm finding myself making flexibility\nsacrifices that I wouldn't normally have to make if I were sticking to vanilla javascript.\n\n\n##### The Solution\nI want to build an endpoint that is separate from the view in a way that makes the site robust and more interactive than what boils down to being\na static render. Yes, the initial rendering of the content is amazingly simple, but I'm struggling to make that content interactive. I would argue that an\nalternate implementation that involves fetching from a JSON endpoint isn't even more complex - the results still need to be transformed similarly as they\nare with EJS, albeit in a much less \"behind-the-scenes\" manner.\n\n\n##### The Implementation\nOn the server, this actually requires only a few small changes-\nFirstly, I want to set a default index page:\n\n`app.use(express.static('static', { index: 'index.html' }));`\n\n\nThis page will be used later to load posts with a `fetch()` call.\n\nNext, I want to make a `posts.json` endpoint. This endpoint will allow fields to be specified in a GraphQL-esque manner for instances where full post\ninformation isn't required. I'm not sure if it will ever be used, but it's free to do:\n\n    app.get('/posts.json', async (req, res) => {\n      let posts;\n      let limit = req.query.limit ? req.query.limit : 500;\n      let target_fields = req.query.fields ?\n        req.query.fields.split(',').reduce((o, field) => (o[field] = 1) && o, {}) : {};\n    \n      try {\n        posts = (await db.find({}, target_fields).sort({ created_ts: -1 }).limit(limit))\n          .map(post => {\n            if(post.body_markdown) {\n              post.body_markdown = marked(post.body_markdown);\n            }\n            return post;\n          });\n    \n        res.json(posts);\n      }\n      catch(error) {\n        console.error(error);\n        res.sendStatus(500);\n      }\n    });\n\nI've also added some logic to sort posts by most recent publications and the ability to limit the result set.\n\nAs aforementioned, the only thing left to do to restore original functionality is to replace the EJS templating with\na call to `fetch()` that results in the posts container being populated:\n\n    let populate_latest_posts = async () => {\n      let latest_posts_div = document.getElementById('latest_posts');\n      let posts = await (await fetch('/posts.json?limit=5')).json();\n      let add_post = post => {\n        let title_h2 = document.createElement('h2');\n        title_h2.textContent = post.title;\n        latest_posts_div.appendChild(title_h2);\n\n        let post_body_div = document.createElement('div');\n        post_body_div.innerHTML = post.body_markdown;\n        latest_posts_div.appendChild(post_body_div);\n      }\n      posts.forEach(add_post);\n    };\n\n##### Conclusion\nWith that, the site behaves exactly as before, but hopefully this new setup will allow me to do things like modifying and adding posts directly, adding preview tiles, and other features that I may desire in the future.","_id":"kNwFlePVkdxD5vKf"}
